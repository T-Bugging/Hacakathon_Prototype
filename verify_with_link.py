# -*- coding: utf-8 -*-
"""Verify_with_link.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F5vWvjZofmfBnxatNhnPvD4Ccf0EItL8
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install google-generativeai
# %pip install feedparser
# %pip install flask

# -*- coding: utf-8 -*-
"""
News Fact Checker from URL
"""

import os
import requests
from bs4 import BeautifulSoup
import feedparser
from urllib.parse import quote_plus
from datetime import datetime, timedelta
from dotenv import load_dotenv
import google.generativeai as genai

# ðŸ”‘ Load API Key
GEMINI_API_KEY = "AIzaSyA0-1QSjRCnLcROFmf3aQ1rWOb3f2DKAhg"
genai.configure(api_key=GEMINI_API_KEY)

MAX_DAYS_LOOKBACK = 30  # Look back window for RSS check




def get_recent_news(query, days=MAX_DAYS_LOOKBACK):
    """Fetch recent related news from Google News RSS."""
    base_url = "https://news.google.com/rss/search?q="
    url = f"{base_url}{quote_plus(query)}&hl=en-IN&gl=IN&ceid=IN:en"
    feed = feedparser.parse(url)
    recent_news = []
    cutoff = datetime.now() - timedelta(days=days)

    for entry in feed.entries:
        if hasattr(entry, "published_parsed"):
            pub_date = datetime(*entry.published_parsed[:6])
            if pub_date >= cutoff:
                recent_news.append({
                    "title": entry.title,
                    "link": entry.link,
                    "published": pub_date
                })
    return recent_news


def fact_check_news(headline, description=""):
    """Run AI fact check on a headline."""
    evidence_news = get_recent_news(headline)
    evidence_titles = [news["title"] for news in evidence_news]

    if not evidence_titles:
        return {
            "prediction": "UNKNOWN",
            "confidence": 0,
            "reason": "No related recent news found"
        }

    evidence_text = "\n".join(f"- {title}" for title in evidence_titles)

    model_input = f"""
    Headline: {headline}
    Description: {description}

    Evidence from reputable sources:
    {evidence_text}

    Based on this evidence, decide if the news is REAL or FAKE.
    Respond in JSON format:
    {{
        "prediction": "REAL or FAKE",
        "confidence": "0-100",
        "reason": "Short explanation"
    }}
    """

    model = genai.GenerativeModel("gemini-2.0-flash")
    response = model.generate_content(model_input)

    return response.text


def extract_headline_from_url(url):
    """Extract headline/title from a given webpage URL."""
    response = requests.get(url, timeout=10)
    soup = BeautifulSoup(response.text, "html.parser")


    if soup.find("meta", property="og:title"):
        return soup.find("meta", property="og:title")["content"].strip()
    elif soup.find("title"):
        return soup.find("title").get_text().strip()
    elif soup.find("h1"):
        return soup.find("h1").get_text().strip()

    return None




if __name__ == "__main__":
    url = input("Enter news article URL: ").strip()
    headline = extract_headline_from_url(url)

    if not headline:
        print("âŒ Could not extract headline.")
    else:
        print(f"\nðŸ“° Headline extracted: {headline}\n")
        result = fact_check_news(headline)
        print("âœ… Fact Check Result:\n", result)

"""# Task
Create a Flask application that takes a URL as input from a frontend, fact-checks the news article at that URL using the existing `extract_headline_from_url` and `fact_check_news` functions, and returns the fact-checking results to the frontend.

## Create a flask application

### Subtask:
Set up a basic Flask application structure.

**Reasoning**:
Import the Flask class and create an instance of the Flask application as instructed.
"""

from flask import Flask

app = Flask(__name__)

"""## Define routes

### Subtask:
Create a route for the homepage where the user can input a URL and a route to handle the fact-checking request.

**Reasoning**:
Define the Flask routes for the homepage and the fact-checking process, handling both GET and POST requests for the homepage and calling the fact-checking functions in the `/check` route.
"""

from flask import render_template, request, redirect, url_for

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        url = request.form["url"]
        return redirect(url_for("check", url=url))
    return render_template("index.html")

@app.route("/check")
def check():
    url = request.args.get("url")
    if not url:
        return render_template("result.html", error="No URL provided.")

    headline = extract_headline_from_url(url)

    if not headline:
        return render_template("result.html", url=url, error="Could not extract headline.")

    result = fact_check_news(headline)
    return render_template("result.html", url=url, headline=headline, result=result)

"""## Integrate fact-checking logic

### Subtask:
Adapt the existing `extract_headline_from_url` and `fact_check_news` functions to be called within the Flask routes.

**Reasoning**:
The existing `extract_headline_from_url` and `fact_check_news` functions are defined in a previous cell. To make them available within the Flask application's scope, they need to be included in the code block where the Flask routes are defined. This step addresses instruction 1. The remaining instructions involve verifying the logic within the routes, which is already present in the provided code for cell `W57fT9U0TTCB` and the previous turn's solution for cell `W57fT9U0TTCB`. Therefore, including the functions from the previous cell will complete the subtask.
"""

import requests
from bs4 import BeautifulSoup
import feedparser
from urllib.parse import quote_plus
from datetime import datetime, timedelta
import google.generativeai as genai
from flask import render_template, request, redirect, url_for

# Assume GEMINI_API_KEY is already set

MAX_DAYS_LOOKBACK = 30  # Look back window for RSS check

def get_recent_news(query, days=MAX_DAYS_LOOKBACK):
    """Fetch recent related news from Google News RSS."""
    base_url = "https://news.google.com/rss/search?q="
    url = f"{base_url}{quote_plus(query)}&hl=en-IN&gl=IN&ceid=IN:en"
    feed = feedparser.parse(url)
    recent_news = []
    cutoff = datetime.now() - timedelta(days=days)

    for entry in feed.entries:
        if hasattr(entry, "published_parsed"):
            pub_date = datetime(*entry.published_parsed[:6])
            if pub_date >= cutoff:
                recent_news.append({
                    "title": entry.title,
                    "link": entry.link,
                    "published": pub_date
                })
    return recent_news


def fact_check_news(headline, description=""):
    """Run AI fact check on a headline."""
    evidence_news = get_recent_news(headline)
    evidence_titles = [news["title"] for news in evidence_news]

    if not evidence_titles:
        return {
            "prediction": "UNKNOWN",
            "confidence": 0,
            "reason": "No related recent news found"
        }

    evidence_text = "\n".join(f"- {title}" for title in evidence_titles)

    model_input = f"""
    Headline: {headline}
    Description: {description}

    Evidence from reputable sources:
    {evidence_text}

    Based on this evidence, decide if the news is REAL or FAKE.
    Respond in JSON format:
    {{
        "prediction": "REAL or FAKE",
        "confidence": "0-100",
        "reason": "Short explanation"
    }}
    """
    # Configure genai inside the function if not configured globally
    try:
        genai.configure(api_key=GEMINI_API_KEY)
    except Exception as e:
        print(f"Error configuring genai: {e}")
        return {
            "prediction": "ERROR",
            "confidence": 0,
            "reason": "API key not configured correctly."
        }

    model = genai.GenerativeModel("gemini-2.0-flash")
    response = model.generate_content(model_input)

    return response.text


def extract_headline_from_url(url):
    """Extract headline/title from a given webpage URL."""
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status() # Raise an exception for bad status codes
    except requests.exceptions.RequestException as e:
        print(f"Error fetching URL {url}: {e}")
        return None


    soup = BeautifulSoup(response.text, "html.parser")


    if soup.find("meta", property="og:title"):
        return soup.find("meta", property="og:title")["content"].strip()
    elif soup.find("title"):
        return soup.find("title").get_text().strip()
    elif soup.find("h1"):
        return soup.find("h1").get_text().strip()

    return None


@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        url = request.form["url"]
        return redirect(url_for("check", url=url))
    return render_template("index.html")

@app.route("/check")
def check():
    url = request.args.get("url")
    if not url:
        return render_template("result.html", error="No URL provided.")

    headline = extract_headline_from_url(url)

    if not headline:
        return render_template("result.html", url=url, error="Could not extract headline.")

    result = fact_check_news(headline)
    return render_template("result.html", url=url, headline=headline, result=result)

"""**Reasoning**:
The error "AssertionError: View function mapping is overwriting an existing endpoint function: index" indicates that the `index` route was already defined in a previous cell. To fix this, the code block should only include the function definitions and the `check` route, as the `index` route was successfully defined in a prior step and should not be redefined.


"""

import requests
from bs4 import BeautifulSoup
import feedparser
from urllib.parse import quote_plus
from datetime import datetime, timedelta
import google.generativeai as genai
from flask import render_template, request, redirect, url_for

# Assume GEMINI_API_KEY is already set

MAX_DAYS_LOOKBACK = 30  # Look back window for RSS check

def get_recent_news(query, days=MAX_DAYS_LOOKBACK):
    """Fetch recent related news from Google News RSS."""
    base_url = "https://news.google.com/rss/search?q="
    url = f"{base_url}{quote_plus(query)}&hl=en-IN&gl=IN&ceid=IN:en"
    feed = feedparser.parse(url)
    recent_news = []
    cutoff = datetime.now() - timedelta(days=days)

    for entry in feed.entries:
        if hasattr(entry, "published_parsed"):
            pub_date = datetime(*entry.published_parsed[:6])
            if pub_date >= cutoff:
                recent_news.append({
                    "title": entry.title,
                    "link": entry.link,
                    "published": pub_date
                })
    return recent_news


def fact_check_news(headline, description=""):
    """Run AI fact check on a headline."""
    evidence_news = get_recent_news(headline)
    evidence_titles = [news["title"] for news in evidence_news]

    if not evidence_titles:
        return {
            "prediction": "UNKNOWN",
            "confidence": 0,
            "reason": "No related recent news found"
        }

    evidence_text = "\n".join(f"- {title}" for title in evidence_titles)

    model_input = f"""
    Headline: {headline}
    Description: {description}

    Evidence from reputable sources:
    {evidence_text}

    Based on this evidence, decide if the news is REAL or FAKE.
    Respond in JSON format:
    {{
        "prediction": "REAL or FAKE",
        "confidence": "0-100",
        "reason": "Short explanation"
    }}
    """
    # Configure genai inside the function if not configured globally
    try:
        genai.configure(api_key=GEMINI_API_KEY)
    except Exception as e:
        print(f"Error configuring genai: {e}")
        return {
            "prediction": "ERROR",
            "confidence": 0,
            "reason": "API key not configured correctly."
        }


    model = genai.GenerativeModel("gemini-2.0-flash")
    response = model.generate_content(model_input)

    return response.text


def extract_headline_from_url(url):
    """Extract headline/title from a given webpage URL."""
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status() # Raise an exception for bad status codes
    except requests.exceptions.RequestException as e:
        print(f"Error fetching URL {url}: {e}")
        return None


    soup = BeautifulSoup(response.text, "html.parser")


    if soup.find("meta", property="og:title"):
        return soup.find("meta", property="og:title")["content"].strip()
    elif soup.find("title"):
        return soup.find("title").get_text().strip()
    elif soup.find("h1"):
        return soup.find("h1").get_text().strip()

    return None


@app.route("/check")
def check():
    url = request.args.get("url")
    if not url:
        return render_template("result.html", error="No URL provided.")

    headline = extract_headline_from_url(url)

    if not headline:
        return render_template("result.html", url=url, error="Could not extract headline.")

    result = fact_check_news(headline)
    return render_template("result.html", url=url, headline=headline, result=result)

"""## Create html templates

### Subtask:
Design simple HTML templates for the input form and to display the fact-checking results.

**Reasoning**:
Create the `templates` directory and the `index.html` and `result.html` files within it, then write the basic HTML structure for both templates as described in the instructions.
"""

import os

# Create the templates directory if it doesn't exist
if not os.path.exists("templates"):
    os.makedirs("templates")

# Create index.html
with open("templates/index.html", "w") as f:
    f.write("""
<!DOCTYPE html>
<html>
<head>
    <title>News Fact Checker</title>
</head>
<body>
    <h1>Enter News Article URL</h1>
    <form method="POST" action="/">
        <label for="url">URL:</label>
        <input type="text" id="url" name="url" size="50">
        <button type="submit">Fact Check</button>
    </form>
</body>
</html>
""")

# Create result.html
with open("templates/result.html", "w") as f:
    f.write("""
<!DOCTYPE html>
<html>
<head>
    <title>Fact Check Result</title>
</head>
<body>
    <h1>Fact Check Result</h1>
    {% if error %}
        <p style="color: red;">Error: {{ error }}</p>
    {% else %}
        <p><strong>Original URL:</strong> {{ url }}</p>
        {% if headline %}
            <p><strong>Extracted Headline:</strong> {{ headline }}</p>
        {% endif %}
        {% if result %}
            <h2>Result</h2>
            <p><strong>Prediction:</strong> {{ result.prediction }}</p>
            <p><strong>Confidence:</strong> {{ result.confidence }}</p>
            <p><strong>Reason:</strong> {{ result.reason }}</p>
        {% else %}
            <p>Could not get fact check result.</p>
        {% endif %}
    {% endif %}
    <p><a href="/">Go back</a></p>
</body>
</html>
""")

"""## Run the flask application

### Subtask:
Add code to run the Flask development server.

**Reasoning**:
Add the code to run the Flask development server within an `if __name__ == "__main__":` block.
"""

if __name__ == "__main__":
    app.run(debug=True)